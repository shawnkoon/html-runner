#!/usr/bin/env node
const stringify = require("rehype-stringify");
const visit = require("unist-util-visit");
const astring = require("astring");
const parse = require("rehype-parse");
const unified = require("unified");
const vfile = require("to-vfile");
const yargs = require("yargs");

const args = yargs.command("run <file>").argv;

const hastToESTree = function() {
  return function transformer(tree, file) {
    let estree = new Node("Program");
    estree.sourceType = "script";
    estree.body = [];

    visit(tree, "element", bodyParse);

    function bodyParse(node) {
      if (node.tagName !== "body") return;
      node.children.forEach(child => {
        if (child.tagName === "ul") {
          let newVar = new Node("VariableDeclaration");
          newVar.kind = "const";
          newVar.declarations = [];

          let newBody = new Node("VariableDeclarator");

          let newId = new Node("Identifier");
          newId.name = child.properties.id;
          newBody.id = newId;

          let newInit = new Node("ArrayExpression");
          newInit.elements = [];

          visit(child, "element", node => {
            if (node.tagName !== "li") return;
            visit(node, "text", contents => {
              let newItem = new Node("Literal");
              newItem.value = contents.value;
              newItem.raw = `'${contents.value}'`;
              newInit.elements.push(newItem);
            });
          });

          newBody.init = newInit;
          newVar.declarations.push(newBody);

          estree.body.push(newVar);
        }

        if (child.tagName === "output") {
          let newExpression = new Node("ExpressionStatement");
          let newCall = new Node("CallExpression");
          let newMember = new Node("MemberExpression");
          newMember.computed = false;

          let newObject = new Node("Identifier");
          newObject.name = child.properties.htmlFor[0];
          newMember.object = newObject;

          let newProperty = new Node("Identifier");
          newProperty.name = "forEach";
          newMember.property = newProperty;

          newCall.callee = newMember;

          let newArrow = new Node("ArrowFunctionExpression");
          newArrow.id = null;
          newArrow.expression = true;
          newArrow.generator = false;
          newArrow.async = false;

          let newParam = new Node("Identifier");
          newParam.name = child.properties.name;
          newArrow.params = [newParam];

          let newArrowBody = new Node("CallExpression");
          let newArrowBodyCall = new Node("MemberExpression");
          newArrowBodyCall.computed = false;

          let newArrowBodyCallObject = new Node("Identifier");
          newArrowBodyCallObject.name = "console";
          newArrowBodyCall.object = newArrowBodyCallObject;

          let newArrowBodyCallProperty = new Node("Identifier");
          newArrowBodyCallProperty.name = "log";
          newArrowBodyCall.property = newArrowBodyCallProperty;

          newArrowBody.callee = newArrowBodyCall;

          let newArrowBodyArgument = new Node("TemplateLiteral");
          let newArrowBodyArgumentExpression = new Node("Identifier");
          newArrowBodyArgumentExpression.name = child.properties.name;
          newArrowBodyArgument.expressions = [newArrowBodyArgumentExpression];

          let newArrowBodyArgumentQuasis = new Node("TemplateElement");
          newArrowBodyArgumentQuasis.value = { raw: "", cooked: "" };
          newArrowBodyArgumentQuasis.cooked = true;
          newArrowBodyArgument.quasis = [newArrowBodyArgumentQuasis];

          newArrowBody.arguments = [newArrowBodyArgument];

          newArrow.body = newArrowBody;
          newCall.arguments = [newArrow];
          newExpression.expression = newCall;

          estree.body.push(newExpression);
        }
      });
    }

    return estree;
  };
};

const estreeToSource = function() {
  this.Compiler = compiler;
  function compiler(tree) {
    return astring.generate(tree);
  }
};

if (args._[0] === "run") {
  unified()
    .use(parse)
    .use(hastToESTree)
    .use(estreeToSource)
    .process(vfile.readSync(args.file), function(err, file) {
      eval(String(file));
    });
}

function Node(type) {
  this.type = type;
  this.body = [];
}
